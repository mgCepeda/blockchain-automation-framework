apiVersion: batch/v1
kind: Job
metadata:
  name: "vaultkubernetes-{{ $.Values.metadata.name }}"
  namespace: "{{ $.Values.metadata.namespace }}"
  labels:
    app.kubernetes.io/name: "{{ $.Values.metadata.name }}"
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
spec:
  backoffLimit: 6
  template:
    metadata:
      labels:
        app: "{{ $.Values.metadata.name }}"
        app.kubernetes.io/name: "{{ $.Values.metadata.name }}"
        helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
        app.kubernetes.io/managed-by: {{ .Release.Service }}
        app.kubernetes.io/instance: {{ .Release.Name }} 
    spec:
      restartPolicy: OnFailure
      imagePullSecrets:
        - name: {{ $.Values.vault.imagesecretname }}
      serviceAccountName: {{ $.Values.vault.serviceaccountname }}
      containers:
        - name:  "vault-kubernetes"
          image: {{ $.Values.metadata.images.fabrictools }}
          imagePullPolicy: IfNotPresent
          env:
          - name: VAULT_ADDR
            value: {{ $.Values.vault.address }}
          - name: KUBERNETES_AUTH_PATH
            value: {{ $.Values.vault.authpath }}
          - name: VAULT_APP_ROLE
            value: {{ $.Values.vault.role }}
          - name: VAULT_SECRET_PREFIX
            value: "{{ $.Values.vault.tmprefix }}"
          command: ["sh", "-c"]
          args:
            - |-
              apk update && apk add jq curl;
              chmod u+x kubectl && mv kubectl /bin/kubectl;

              # create build folder??
              mkir -m 755 ../../../configuration/build2

              validateVaultResponse () {
                if echo ${2} | grep "errors"; then
                  echo "ERROR: unable to retrieve ${1}: ${2}"
                  exit 1
                fi
                if  [ "$3" == "LOOKUPSECRETRESPONSE" ]
                then
                  http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
                  --header "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" \
                  ${VAULT_ADDR}/v1/${vault_secret_key})
                  curl_response=$?
                  if test "$http_code" != "200" ; then
                      echo "Http response code from Vault - $http_code"
                      if test "$curl_response" != "0"; then
                        echo "Error: curl command failed with error code - $curl_response"
                        exit 1
                      fi
                  fi
                fi
              }

              KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              echo "Getting secrets from Vault Server: ${VAULT_ADDR}"

              # Login to Vault and so I can get an approle token
              VAULT_CLIENT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login \
                -H "Content-Type: application/json" \
                -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | \
                jq -r 'if .errors then . else .auth.client_token end')
              validateVaultResponse 'vault login token' "${VAULT_CLIENT_TOKEN}"
              
              export VAULT_SA_NAME=$(kubectl kubectl get serviceaccount -n {{ $.Values.metadata.namespace }} -o jsonpath="{.secrets[*]['name']}");
              export SA_JWT_TOKEN=$(kubectl get secret $VAULT_SA_NAME -n {{ $.Values.metadata.namespace }} -o jsonpath="{.data.token}" | base64 -d; echo);
              export SA_CA_CRT_ONELINE=$(kubectl get secret $VAULT_SA_NAME -n {{ $.Values.metadata.namespace }} -o jsonpath="{.data['ca\.crt']}" | base64 -d | awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}');

              # Create auth 
              curl \
                --header "X-Vault-Token: $VAULT_CLIENT_TOKEN" \
                --request POST \
                --data '{"type": "kubernetes"}' \
                ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH};

              curl \
                --header "X-Vault-Token: $VAULT_TOKEN" \
                --request POST \
                --data '{"kubernetes_host": "{{ $.Values.k8s.url }}", "kubernetes_ca_cert": "'"$SA_CA_CRT_ONELINE"'", "token_reviewer_jwt": "'"$SA_JWT_TOKEN"'"}' \
                -s -k ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/config;

              export VAULT_TOKEN={{ $.Values.vault.root }};
              export VAULT_ADDR= ${VAULT_ADDR};
             
              vault auth enable --path="${VAULT_ADDR}" kubernetes

              KUBECONFIG={{ $.Values.k8s.config_file }} kubectl -n {{ $.Values.metadata.name }} get secrets $(KUBECONFIG={{ $.Values.k8s.config_file }} kubectl -n {{ $.Values.metadata.name }} get secrets | grep "default" | awk '{print $1}') -o jsonpath="{.data['ca\.crt']}" | base64 -d > "./build/{{ $.Values.metadata.name }}.ca.cert";

              export REVIEWER_TOKEN=$(KUBECONFIG={{ $.Values.k8s.config_file }} kubectl get secret $(KUBECONFIG={{  $.Values.k8s.config_file }} kubectl get serviceaccount -n {{ $.Values.metadata.name }} vault-reviewer -o jsonpath={.secrets[0].name}) -n {{ $.Values.metadata.name }} -o  jsonpath={.data.token} | base64 -d);
              vault write auth/${VAULT_ADDR}/config token_reviewer_jwt="${REVIEWER_TOKEN}" kubernetes_host=$(KUBECONFIG={{ $.Values.k8s.config_file }} kubectl config view -o jsonpath="{.clusters[?(@.name==\"{{ $.Values.k8s.context }}\")].cluster.server}") kubernetes_ca_cert=@"./build/{{ $.Values.metadata.name }}.ca.cert";
              
              # Create policy
              curl \
                --header "X-Vault-Token: $VAULT_CLIENT_TOKEN" \
                --request PUT \
                --data '{"policy":"# Dev servers have version 2 of KV secrets engine mounted by default, so will\n# need these paths to grant permissions:\npath \"secret/data/*\" {\n  capabilities = [\"create\", \"update\"]\n}\n\npath \"secret/data/foo\" {\n  capabilities = [\"read\"]\n}\n"}' \
                http://127.0.0.1:8200/v1/sys/policies/acl/my-policy
                          
              curl \
                --header "X-Vault-Token: $VAULT_TOKEN" \
                --request PUT \
                --data '{"policy": "{{ $.Values.vault.policy_content }}"}' \
                {{ $.Values.vault.address }}/v1/sys/policy/{{ $.Values.vault.policy }};



              vault_secret_key="${VAULT_SECRET_PREFIX}"

          
              # Generate tessera keys
              tessera -keygen -filename nodeKey < /dev/null

              #encode to base64 to update to vault otherwise json format is creating problems with vault api
              nodekey_base64=$(base64 nodeKey.key | tr -d \\n)

              # Save the generated keys to VAULT
              LOOKUP_SECRET_RESPONSE=$(curl -sS -H "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" \
                -H "Content-Type: application/json" \
                -X POST \
                -d '{"key":"'"$nodekey_base64"'","key_pub":"'"$(cat nodeKey.pub)"'"}' \
                ${VAULT_ADDR}/v1/${vault_secret_key} | \
                jq -r 'if .errors then . else .auth.client_token end')
              
              validateVaultResponse "secret (${vault_secret_key})" "${LOOKUP_SECRET_RESPONSE}" "LOOKUPSECRETRESPONSE"
